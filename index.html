<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zultra Modeler</title>
    <!-- Tailwind CSS CDN for styling the UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the body and overall vertical layout */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            display: flex;
            flex-direction: column; /* Stack top bar and main content vertically */
            height: 100vh;
            background-color: #1f2937; /* Dark background */
        }
        
        /* New wrapper for Left Panel + Canvas */
        #main-content-wrapper {
            display: flex; /* Horizontal split */
            flex-grow: 1;
            overflow: hidden;
        }

        #left-panel {
            width: 256px; /* Fixed width for the panel */
            background-color: #374151; /* Slightly lighter gray for the panel */
            flex-shrink: 0;
            overflow-y: auto;
            border-right: 1px solid #1f2937;
            display: flex; /* Enable flex for vertical content distribution */
            flex-direction: column;
        }

        #canvas-container {
            flex-grow: 1; /* Take up all remaining space */
            position: relative;
        }
        
        /* --- MODE BUTTON STYLING (Fixed: Prominent, distinct buttons with high contrast) --- */
        .mode-button {
            /* Base styling for all mode buttons */
            @apply px-3 py-1.5 text-sm font-semibold transition duration-150 rounded-lg shadow-md;
        }
        .mode-active {
            /* Active state: Bright yellow background */
            @apply bg-yellow-500 text-gray-900 hover:bg-yellow-400; 
        }
        .mode-inactive {
            /* Inactive state: High-contrast light gray block for clear button definition */
            @apply text-gray-900 bg-gray-300 hover:bg-gray-400; 
        }
        /* ---------------------------------------------------------------------- */

        #selection-status-text {
            @apply text-xs text-gray-300 px-2 py-1 bg-gray-700 rounded-lg whitespace-nowrap;
        }
        #color-picker {
            border: 2px solid #374151;
            cursor: pointer;
            padding: 0;
        }

        /* Scene List Item Styling */
        .scene-item {
            @apply p-2 text-sm text-gray-200 cursor-pointer rounded-md transition duration-100 mb-1 truncate;
        }
        .scene-item:hover {
            @apply bg-gray-600;
        }
        .scene-item.selected {
            @apply bg-blue-600 font-bold text-white;
        }
    </style>
</head>
<body>

    <!-- Top Control Bar (All Tools) -->
    <div id="top-bar" class="flex items-center justify-between p-2 bg-gray-800 shadow-xl border-b border-gray-700">

        <!-- Left Section: Creation Tools -->
        <div class="flex space-x-1.5 items-center">
            <h1 class="text-lg font-bold text-white pr-2 border-r border-gray-700">3D Builder</h1>
            <button onclick="addShape('box')" class="py-1 px-2 bg-blue-600 hover:bg-blue-700 text-white text-sm rounded-lg shadow-md transition duration-200">
                Cube
            </button>
            <button onclick="addShape('sphere')" class="py-1 px-2 bg-purple-600 hover:bg-purple-700 text-white text-sm rounded-lg shadow-md transition duration-200">
                Sphere
            </button>
            <button onclick="addShape('torus')" class="py-1 px-2 bg-green-600 hover:bg-green-700 text-white text-sm rounded-lg shadow-md transition duration-200">
                Torus
            </button>
            
            <button onclick="addShape('triangle')" class="py-1 px-2 bg-yellow-600 hover:bg-yellow-700 text-white text-sm rounded-lg shadow-md transition duration-200">
                Triangle
            </button>
            <button onclick="addShape('cylinder')" class="py-1 px-2 bg-indigo-600 hover:bg-indigo-700 text-white text-sm rounded-lg shadow-md transition duration-200">
                Cylinder
            </button>
        </div>

        <!-- Center Section: Interactive Mode Toggles (Now in one box) -->
        <div class="flex space-x-1.5 p-1 rounded-lg bg-gray-700 shadow-inner items-center">
            <button id="mode-translate" onclick="setTransformMode('translate')" class="mode-button mode-active">
                Move
            </button>
            <button id="mode-rotate" onclick="setTransformMode('rotate')" class="mode-button mode-inactive">
                Rotate
            </button>
            <button id="mode-scale" onclick="setTransformMode('scale')" class="mode-button mode-inactive">
                Scale
            </button>
        </div>

        <!-- Right Section: Status, Color, and Delete -->
        <div class="flex space-x-3 items-center">
            <span id="selection-status-text">No object selected.</span>
            
            <!-- Color Picker Group -->
            <div class="flex items-center space-x-1">
                <label for="color-picker" class="text-sm font-medium text-gray-300">Color:</label>
                <input type="color" id="color-picker" oninput="setColor(this.value)" class="w-8 h-8 rounded-lg shadow-md disabled:opacity-50" disabled>
            </div>
            
            <button id="delete-btn" onclick="deleteObject()" class="py-1 px-3 bg-red-600 hover:bg-red-700 text-white text-sm font-semibold rounded-lg shadow-md transition duration-200 disabled:opacity-50" disabled>
                Delete
            </button>
        </div>
    </div>

    <!-- Main Content Area: Scene Panel and Canvas -->
    <div id="main-content-wrapper">
        
        <!-- Left Panel: Scene Hierarchy & Renaming -->
        <div id="left-panel" class="p-3">
            <h2 class="text-lg font-bold text-white mb-3 pb-2 border-b border-gray-600">Viewer</h2>
            
            <!-- Scrollable Object List -->
            <div id="scene-list-container" class="flex-grow overflow-y-auto">
                <div id="scene-list" class="mb-4">
                    <!-- Object list will be populated here -->
                </div>
            </div>
            
            <!-- Rename Tool -->
            <div class="mt-4 pt-4 border-t border-gray-600 flex-shrink-0">
                <label for="rename-input" class="text-sm text-gray-400 block mb-1">Rename Selected:</label>
                <input type="text" id="rename-input" placeholder="Object Name" oninput="renameSelected(this.value)" class="w-full p-2 bg-gray-600 text-white rounded text-sm disabled:opacity-50" disabled>
            </div>

            <!-- File Operations (Export/Import) -->
            <div class="mt-4 pt-4 border-t border-gray-600 flex-shrink-0 space-y-3">
                <h3 class="text-sm font-bold text-gray-300">File Operations (OBJ)</h3>
                
                <!-- Export Button -->
                <button onclick="exportOBJ()" class="w-full p-2 bg-blue-500 hover:bg-blue-600 text-white rounded text-sm font-semibold shadow-md transition duration-200">
                    Export Scene (.obj)
                </button>
                
                <!-- Import Button (Styled as a button using label) -->
                <label for="import-input" class="w-full flex justify-center p-2 bg-green-500 hover:bg-green-600 text-white rounded text-sm font-semibold shadow-md transition duration-200 cursor-pointer">
                    Import (.obj)
                    <input type="file" id="import-input" accept=".obj" onchange="handleImport(event)" class="hidden">
                </label>
                <p class="text-xs text-gray-400 mt-1">Note: Complex formats like FBX are not supported in this environment.</p>
            </div>

        </div>

        <!-- Canvas Container -->
        <div id="canvas-container">
            <!-- The Three.js renderer will append its canvas here -->
        </div>
    </div>
    
    <!-- Three.js Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <!-- Add OBJ Loader and Exporter -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/OBJExporter.js"></script>


    <script>
        // --- Global Variables and Setup ---
        let scene, camera, renderer, controls, raycaster, mouse;
        let transformControls;
        let selectedObject = null;
        const objects = [];
        const INTERSECTED_COLOR = 0xffa500; // Orange for selected
        const DEFAULT_COLOR = 0x1e90ff; // Dodger Blue
        let objectCounter = 1;
        
        let objLoader;
        let objExporter;

        // --- Initialization Function ---
        function init() {
            const container = document.getElementById('canvas-container');

            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2d3748);

            // Camera Setup
            camera = new THREE.PerspectiveCamera(75, 2, 0.1, 1000); 
            camera.position.set(5, 5, 5);

            // Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            container.appendChild(renderer.domElement);
            
            // Call resize immediately to set initial size and camera aspect
            onWindowResize(); 

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);

            // Orbit Controls (Camera navigation)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 1;
            controls.maxDistance = 50;
            controls.target.set(0, 0, 0); 

            // Transform Controls (Gizmo for object manipulation)
            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            transformControls.visible = false;
            scene.add(transformControls);
            transformControls.setMode("translate"); // Default mode

            // TransformControls Events
            transformControls.addEventListener('change', animate);
            
            transformControls.addEventListener('dragging-changed', function (event) {
                // Disable OrbitControls while the gizmo is being dragged
                controls.enabled = !event.value; 
            });
            
            // Initialize OBJ Loader and Exporter
            objLoader = new THREE.OBJLoader();
            objExporter = new THREE.OBJExporter();


            // Raycaster and Mouse vector for interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Add a ground plane for reference
            const planeGeometry = new THREE.PlaneGeometry(20, 20);
            const planeMaterial = new THREE.MeshPhongMaterial({ color: 0x4a5568, side: THREE.DoubleSide });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = Math.PI / 2;
            plane.position.y = -2;
            scene.add(plane);

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('click', onCanvasClick, false);
            
            // Initial hierarchy update
            updateSceneHierarchy();

            // Start the animation loop
            animate();
        }

        // --- Core Functions ---

        /**
         * Animation loop
         */
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); 
            renderer.render(scene, camera);
        }

        /**
         * Handles window resizing to keep the canvas responsive and sets initial size.
         */
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Only update if dimensions are valid (prevents issues on load)
            if (width > 0 && height > 0) {
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            }
        }

        /**
         * Renders the current list of objects in the Scene Hierarchy panel.
         */
        function updateSceneHierarchy() {
            const sceneList = document.getElementById('scene-list');
            sceneList.innerHTML = ''; // Clear existing list

            objects.forEach((obj, index) => {
                const item = document.createElement('div');
                item.textContent = obj.userData.name;
                item.classList.add('scene-item');
                
                // Add index and event listener to select via panel
                item.dataset.index = index;
                item.addEventListener('click', () => {
                    selectObject(obj);
                });

                // Highlight if currently selected
                if (selectedObject === obj) {
                    item.classList.add('selected');
                }

                sceneList.appendChild(item);
            });
        }

        /**
         * Renames the currently selected object.
         * @param {string} newName - The new name for the object.
         */
        function renameSelected(newName) {
            if (!selectedObject || !newName.trim()) return;
            selectedObject.userData.name = newName.trim();
            updateSceneHierarchy();
        }

        /**
         * Sets the mode for the TransformControls gizmo.
         * Also updates the visual state of the mode buttons.
         * @param {string} mode - 'translate', 'rotate', or 'scale'.
         */
        function setTransformMode(mode) {
            transformControls.setMode(mode);
            
            // Update button styles
            ['translate', 'rotate', 'scale'].forEach(m => {
                const btn = document.getElementById(`mode-${m}`);
                if (btn) {
                    if (m === mode) {
                        btn.classList.remove('mode-inactive');
                        btn.classList.add('mode-active');
                    } else {
                        btn.classList.remove('mode-active');
                        btn.classList.add('mode-inactive');
                    }
                }
            });
            console.log("Gizmo Mode:", mode);
        }
        
        /**
         * Sets the color of the selected object using a hex string.
         * @param {string} colorHex - The new color in hex string format (e.g., #ff0000).
         */
        function setColor(colorHex) {
            if (!selectedObject) return;
            selectedObject.material.color.set(colorHex);
            selectedObject.userData.customColor = colorHex; // Store custom color for re-selection
        }
        
        /**
         * Maps type key to a display name.
         * @param {string} type - The geometry key ('box', 'sphere', etc.).
         * @returns {string} The capitalized display name.
         */
        function getBaseName(type) {
            const shapeMap = {
                'box': 'Cube',
                'sphere': 'Sphere',
                'torus': 'Torus',
                'cylinder': 'Cylinder',
                'triangle': 'Triangle',
            };
            return shapeMap[type] || 'Object';
        }

        /**
         * Adds a basic shape to the scene.
         * @param {string} type - The type of geometry ('box', 'sphere', 'torus', 'triangle', 'cylinder').
         */
        function addShape(type) {
            let geometry;
            switch (type) {
                case 'box':
                    geometry = new THREE.BoxGeometry(1, 1, 1);
                    break;
                case 'sphere':
                    geometry = new THREE.SphereGeometry(0.75, 32, 32);
                    break;
                case 'torus':
                    geometry = new THREE.TorusGeometry(0.7, 0.3, 16, 100);
                    break;
                case 'cylinder':
                    // Standard Cylinder
                    geometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 32);
                    break;
                case 'triangle':
                    // Triangular Prism (Cylinder with 3 radial segments)
                    geometry = new THREE.CylinderGeometry(0.75, 0.75, 1.5, 3);
                    break;
                default:
                    return;
            }

            const material = new THREE.MeshPhongMaterial({ color: DEFAULT_COLOR });
            const mesh = new THREE.Mesh(geometry, material);

            mesh.position.set(
                (Math.random() - 0.5) * 5,
                (Math.random() * 2) + 0.5,
                (Math.random() - 0.5) * 5
            );
            
            // Get base name and use the counter for uniqueness (e.g., "Cube 1")
            const baseName = getBaseName(type);
            const defaultName = baseName + ' ' + objectCounter++;
            mesh.userData.name = defaultName;
            mesh.userData.customColor = '#' + new THREE.Color(DEFAULT_COLOR).getHexString();

            objects.push(mesh);
            scene.add(mesh);
            
            // Auto-select the newly created object
            selectObject(mesh);
            updateSceneHierarchy(); // Update the list after adding
        }

        /**
         * Handles mouse clicks on the canvas for object selection (Raycasting).
         */
        function onCanvasClick(event) {
            if (transformControls.dragging) {
                return;
            }

            const container = document.getElementById('canvas-container');
            const rect = renderer.domElement.getBoundingClientRect();

            mouse.x = ((event.clientX - rect.left) / container.clientWidth) * 2 - 1;
            mouse.y = - ((event.clientY - rect.top) / container.clientHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(objects, false);

            if (intersects.length > 0) {
                selectObject(intersects[0].object);
            } else {
                selectObject(null);
            }
        }

        /**
         * Sets or clears the selected object.
         * @param {THREE.Mesh | null} object - The object to select or null to deselect.
         */
        function selectObject(object) {
            const colorPicker = document.getElementById('color-picker');
            const renameInput = document.getElementById('rename-input');

            // 1. Deselect previous object
            if (selectedObject) {
                const storedColor = selectedObject.userData.customColor || '#' + new THREE.Color(DEFAULT_COLOR).getHexString();
                selectedObject.material.color.set(storedColor);
            }

            // 2. Set new selection
            selectedObject = object;

            // 3. Update UI and visual state
            const statusTextEl = document.getElementById('selection-status-text');
            const deleteBtn = document.getElementById('delete-btn');

            if (selectedObject) {
                const currentHex = '#' + selectedObject.material.color.getHexString();
                selectedObject.userData.customColor = currentHex; 
                
                selectedObject.material.color.setHex(INTERSECTED_COLOR);

                transformControls.attach(selectedObject);
                transformControls.visible = true;
                setTransformMode(transformControls.mode);

                // Update Color Picker
                colorPicker.value = currentHex;
                colorPicker.disabled = false;

                // Update Rename Input
                renameInput.value = selectedObject.userData.name;
                renameInput.disabled = false;
                
                // Update UI status
                statusTextEl.textContent = `Selected: ${selectedObject.userData.name}`;
                deleteBtn.disabled = false;
            } else {
                // Clear UI status
                statusTextEl.textContent = 'No object selected.';
                deleteBtn.disabled = true;
                colorPicker.disabled = true;
                renameInput.value = '';
                renameInput.disabled = true;
                transformControls.detach();
                transformControls.visible = false;
            }
            
            updateSceneHierarchy(); // Update the hierarchy list to reflect selection state
        }
        
        /**
         * Deletes the currently selected object from the scene and the objects array.
         */
        function deleteObject() {
            if (!selectedObject) return;

            // Remove gizmo first
            transformControls.detach();

            // Remove from the scene
            scene.remove(selectedObject);

            // Remove from the tracking array
            const index = objects.indexOf(selectedObject);
            if (index > -1) {
                objects.splice(index, 1);
            }

            // Dispose of geometry and material to free memory (best practice)
            selectedObject.geometry.dispose();
            selectedObject.material.dispose();

            // Deselect
            selectObject(null);
            updateSceneHierarchy(); // Update the list after deletion
            console.log("Object deleted.");
        }

        /**
         * Handles the file import event (only supports OBJ).
         * @param {Event} event - The file change event.
         */
        function handleImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const object = objLoader.parse(e.target.result);
                    
                    let firstMesh = null;

                    // Traverse imported object to find meshes and add them to the scene
                    object.traverse(function (child) {
                        if (child.isMesh) {
                            // Apply a standard material with the default color
                            child.material = new THREE.MeshPhongMaterial({ color: DEFAULT_COLOR });
                            
                            // Set initial user data
                            const baseName = "Imported";
                            const defaultName = baseName + ' ' + objectCounter++;
                            child.userData.name = defaultName;
                            child.userData.customColor = '#' + new THREE.Color(DEFAULT_COLOR).getHexString();

                            objects.push(child);
                            scene.add(child);
                            if (!firstMesh) firstMesh = child;
                        }
                    });

                    updateSceneHierarchy();
                    selectObject(firstMesh); // Select first mesh found
                    console.log(`Imported geometry from ${file.name}`);
                } catch (error) {
                    console.error("Error importing OBJ file:", error);
                }
            };
            reader.readAsText(file);
        }

        /**
         * Exports the entire scene as a single OBJ file.
         */
        function exportOBJ() {
            // Exporter needs a group or scene to process
            const exportGroup = new THREE.Group();
            objects.forEach(obj => exportGroup.add(obj.clone())); // Clone objects to avoid changing scene

            const result = objExporter.parse(exportGroup);

            // Create a Blob and link to trigger download
            const blob = new Blob([result], { type: 'text/plain' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = '3d_builder_scene.obj';
            a.click();
            
            // Clean up the temporary URL
            URL.revokeObjectURL(a.href);
            
            console.log("Scene exported as OBJ.");
        }


        // Wait for the window to load before starting the 3D application
        window.onload = init;
    </script>
</body>
</html>
